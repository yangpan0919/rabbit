spring.rabbitmq.host=127.0.0.1
spring.rabbitmq.port=5672
spring.rabbitmq.virtualHost=test
spring.rabbitmq.username=admin
spring.rabbitmq.password=admin
#并发消费者的初始化值，
spring.rabbitmq.listener.concurrency=10
#并发消费者的最大值，
spring.rabbitmq.listener.max-concurrency=20
#每个消费者每次监听时可拉取处理的消息数量。
spring.rabbitmq.listener.prefetch=5
#开启重试，默认为false，无限重试
# 我想既然配置了重试机制消息肯定是很重要的，消息肯定不能丢，仅仅是日志可能会因为日志滚动丢失而且信息不明显，所以我们要讲消息保存下来。可以有如下这些方案：

#使用RepublishMessageRecoverer这个MessageRecoverer会发送发送消息到指定队列
#给队列绑定死信队列，因为默认的RepublishMessageRecoverer会发送nack并且requeue为false。这样抛出一场是这种方式和上面的结果一样都是转发到了另外一个队列。详见DeadLetterConsumer
#注册自己实现的MessageRecoverer
#给MessageListenerContainer设置RecoveryCallback
#对于方法手动捕获异常，进行处理
spring.rabbitmq.listener.simple.retry.enabled=true
spring.rabbitmq.listener.direct.retry.enabled=true

